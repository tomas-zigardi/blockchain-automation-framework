apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: "{{ $.Values.metadata.name }}"
  namespace: "{{ $.Values.metadata.namespace }}"
spec:
  serviceName: "{{ $.Values.metadata.name }}"
  replicas: 1
  selector:
    matchLabels:
      app: "{{ $.Values.metadata.name }}"
  template:
    metadata:
      labels:
        app: "{{ $.Values.metadata.name }}"
    spec:
      securityContext:
        fsGroup: 1000
      serviceAccountName: {{ $.Values.vault.serviceaccountname }}
      initContainers:
      - name:  "{{ $.Values.image.initContainer.name }}"
        image:  "{{ $.Values.image.initContainer.repository }}"
        imagePullPolicy: Always
        env:
         - name: VAULT_ADDR
           value: {{ $.Values.vault.address }}
         - name: KEY_PATH
           value: {{ $.Values.vault.keyPath }}
         - name: NODE_ID
           value: {{ $.Values.vault.nodeId }}
         - name: ORGANIZATION_NAME
           value: "{{ $.Values.organization.name }}"
        command:
        - "sh"
        - "-c"
        - >
          apk update;
          apk add curl jq;

          validateVaultResponse () {
          if echo ${2} | grep "errors"; then
           echo "ERROR: unable to retrieve ${1}: ${2}"
           exit 1
           fi
          }

          KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token);
          
          response=$(curl -s -o /dev/null -w "%{http_code}" $VAULT_ADDR/v1/sys/health)
          if [ $response -ne 200 ]
          then
            exit 1
          fi
          
          curl --request POST --data '{"jwt": "'"$KUBE_TOKEN"'", "role": "ro"}' $VAULT_ADDR/v1/auth/kubernetes/${NODE_ID}/login | jq -j '.auth.client_token' > token;
          X_VAULT_TOKEN=$(cat token);


          mkdir -p ${KEY_PATH}/bls_keys
          mkdir -p ${KEY_PATH}/private_keys
          mkdir -p ${KEY_PATH}/public_keys
          mkdir -p ${KEY_PATH}/sig_keys
          mkdir -p ${KEY_PATH}/verif_keys
          mkdir -p ${KEY_PATH}C/private_keys
          mkdir -p ${KEY_PATH}C/public_keys
          mkdir -p ${KEY_PATH}C/sig_keys
          mkdir -p ${KEY_PATH}C/verif_keys

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/bls_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/bls_keys)" "${LOOKUP_SECRET_RESPONSE}"
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data.bls_pk' > ${KEY_PATH}/bls_keys/bls_pk;
          chmod 644 ${KEY_PATH}/bls_keys/bls_pk;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/bls_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/bls_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data.bls_sk' > ${KEY_PATH}/bls_keys/bls_sk;
          chmod 640 ${KEY_PATH}/bls_keys/bls_sk;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/private_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/private_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}.key_secret"' > ${KEY_PATH}/private_keys/${NODE_ID}.key_secret;
          chmod 640 ${KEY_PATH}/private_keys/${NODE_ID}.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/public_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/public_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}.key.bootstrap"' > ${KEY_PATH}/public_keys/${NODE_ID}.key.bootstrap;
          chmod 644 ${KEY_PATH}/public_keys/${NODE_ID}.key.bootstrap;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/private/sig_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/sig_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}.key_secret"' > ${KEY_PATH}/sig_keys/${NODE_ID}.key_secret;
          chmod 640 ${KEY_PATH}/sig_keys/${NODE_ID}.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}/node/public/verif_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}/verif_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}.key.bootstrap"' > ${KEY_PATH}/verif_keys/${NODE_ID}.key.bootstrap;
          chmod 644 ${KEY_PATH}/verif_keys/${NODE_ID}.key.bootstrap;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}C/node/private/private_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}C/private_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}C.key_secret"' > ${KEY_PATH}C/private_keys/${NODE_ID}C.key_secret;
          chmod 640 ${KEY_PATH}C/private_keys/${NODE_ID}C.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}C/node/public/public_keys  | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}C/public_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}C.key"' > ${KEY_PATH}C/public_keys/${NODE_ID}C.key;
          chmod 644 ${KEY_PATH}C/public_keys/${NODE_ID}C.key;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}C/node/private/sig_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}C/sig_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" |jq -j '.data."${NODE_ID}C.key_secret"' > ${KEY_PATH}C/sig_keys/${NODE_ID}C.key_secret;
          chmod 640 ${KEY_PATH}C/sig_keys/${NODE_ID}C.key_secret;

          LOOKUP_SECRET_RESPONSE=$(curl --header "X-Vault-Token: $X_VAULT_TOKEN" $VAULT_ADDR/v1/kv/"${ORGANIZATION_NAME}"/stewards/${NODE_ID}C/node/public/verif_keys | jq -r 'if .errors then . else . end');
          validateVaultResponse "secret (kv/${NODE_ID}C/verif_keys)" "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}";
          echo "${LOOKUP_SECRET_RESPONSE}" | jq -j '.data."${NODE_ID}C.key"' > ${KEY_PATH}C/verif_keys/${NODE_ID}C.key;
          chmod 644 ${KEY_PATH}C/verif_keys/${NODE_ID}C.key;
        volumeMounts:
        - name: ebs-indy-node-keys
          mountPath: /keys
      containers:
        - name: "{{ $.Values.image.indyNode.name }}"
          image: "{{ $.Values.image.indyNode.repository }}"
          imagePullPolicy: Always
          ports:
            - containerPort: {{ $.Values.node.port }}
            - containerPort: {{ $.Values.client.port }}
          env:
            - name: INDY_NODE_NAME
              value: "{{ $.Values.node.name }}"
            - name: INDY_NODE_IP
              value: "{{ $.Values.node.ip }}"
            - name: INDY_NODE_PORT
              value: "{{ $.Values.node.port }}"
            - name: INDY_CLIENT_IP
              value: "{{ $.Values.client.ip }}"
            - name: INDY_CLIENT_PORT
              value: "{{ $.Values.client.port }}"
            - name: INDY_NETWORK_NAME
              value: "{{ $.Values.network.name }}"
          volumeMounts:
            - name: ebs-indy-node-data
              mountPath: /var/lib/indy/data
            - name: ebs-indy-node-keys
              mountPath: /var/lib/indy/keys
            - name: {{ $.Values.node.name }}-config
              mountPath: /etc/indy/indy_config.py
              subPath: indy_config.py
            - name: {{ $.Values.organization.name }}-domain-transactions-genesis
              mountPath: /var/lib/indy/genesis/{{ $.Values.network.name }}/domain_transactions_genesis
              subPath: domain_transactions_genesis
            - name: {{ $.Values.organization.name }}-pool-transactions-genesis
              mountPath: /var/lib/indy/genesis/{{ $.Values.network.name }}/pool_transactions_genesis
              subPath: pool_transactions_genesis
      imagePullSecrets:
        - name: "{{ $.Values.image.pullSecret }}"
      volumes:
        - name: {{ $.Values.node.name }}-config
          configMap:
            name: {{ $.Values.node.name }}-config
        - name:  {{ $.Values.organization.name }}-domain-transactions-genesis
          configMap:
            name: {{ $.Values.organization.name }}-domain-transactions-genesis
        - name: {{ $.Values.organization.name }}-pool-transactions-genesis
          configMap:
            name: {{ $.Values.organization.name }}-pool-transactions-genesis
  volumeClaimTemplates:
    - metadata:
        name: ebs-indy-node-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "{{ $.Values.storage.data.storageClassName }}"
        resources:
          requests:
            storage: "{{ $.Values.storage.data.storagesize }}"
    - metadata:
        name: ebs-indy-node-keys
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: "{{ $.Values.storage.data.storageClassName }}"
        resources:
          requests:
            storage: "{{ $.Values.storage.keys.storagesize }}"
